// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: temporal/v1/temporal_types.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// 执行模式
type ExecutionMode int32

const (
	ExecutionMode_MODE_UNSPECIFIED ExecutionMode = 0 // 未知类型
	ExecutionMode_MODE_IMMEDIATE   ExecutionMode = 1 // 立即执行
	ExecutionMode_MODE_DELAYED     ExecutionMode = 2 // 延迟执行
	ExecutionMode_MODE_SCHEDULED   ExecutionMode = 3 // 调度执行 (Cron)
	ExecutionMode_MODE_AT_TIME     ExecutionMode = 4 // 指定时间执行
	ExecutionMode_MODE_BATCH       ExecutionMode = 5 // 批量执行
)

// Enum value maps for ExecutionMode.
var (
	ExecutionMode_name = map[int32]string{
		0: "MODE_UNSPECIFIED",
		1: "MODE_IMMEDIATE",
		2: "MODE_DELAYED",
		3: "MODE_SCHEDULED",
		4: "MODE_AT_TIME",
		5: "MODE_BATCH",
	}
	ExecutionMode_value = map[string]int32{
		"MODE_UNSPECIFIED": 0,
		"MODE_IMMEDIATE":   1,
		"MODE_DELAYED":     2,
		"MODE_SCHEDULED":   3,
		"MODE_AT_TIME":     4,
		"MODE_BATCH":       5,
	}
)

func (x ExecutionMode) Enum() *ExecutionMode {
	p := new(ExecutionMode)
	*p = x
	return p
}

func (x ExecutionMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExecutionMode) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[0].Descriptor()
}

func (ExecutionMode) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[0]
}

func (x ExecutionMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExecutionMode.Descriptor instead.
func (ExecutionMode) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{0}
}

// 控制操作
type ControlOperation int32

const (
	ControlOperation_OPT_UNSPECIFIED ControlOperation = 0 // 未知类型
	ControlOperation_OPT_CANCEL      ControlOperation = 1 // 优雅取消
	ControlOperation_OPT_TERMINATE   ControlOperation = 2 // 强制终止
	ControlOperation_OPT_PAUSE       ControlOperation = 3 // 暂停 (调度)
	ControlOperation_OPT_RESUME      ControlOperation = 4 // 恢复 (调度)
	ControlOperation_OPT_RESET       ControlOperation = 5 // 重置到某个点
)

// Enum value maps for ControlOperation.
var (
	ControlOperation_name = map[int32]string{
		0: "OPT_UNSPECIFIED",
		1: "OPT_CANCEL",
		2: "OPT_TERMINATE",
		3: "OPT_PAUSE",
		4: "OPT_RESUME",
		5: "OPT_RESET",
	}
	ControlOperation_value = map[string]int32{
		"OPT_UNSPECIFIED": 0,
		"OPT_CANCEL":      1,
		"OPT_TERMINATE":   2,
		"OPT_PAUSE":       3,
		"OPT_RESUME":      4,
		"OPT_RESET":       5,
	}
)

func (x ControlOperation) Enum() *ControlOperation {
	p := new(ControlOperation)
	*p = x
	return p
}

func (x ControlOperation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ControlOperation) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[1].Descriptor()
}

func (ControlOperation) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[1]
}

func (x ControlOperation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ControlOperation.Descriptor instead.
func (ControlOperation) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{1}
}

// 控制结果
type ControlResult int32

const (
	ControlResult_CONTROL_UNSPECIFIED       ControlResult = 0 // 未知类型
	ControlResult_CONTROL_SUCCESS           ControlResult = 1
	ControlResult_CONTROL_ALREADY_COMPLETED ControlResult = 2
	ControlResult_CONTROL_ALREADY_CANCELLED ControlResult = 3
	ControlResult_CONTROL_NOT_FOUND         ControlResult = 4
	ControlResult_CONTROL_OPERATION_FAILED  ControlResult = 5
)

// Enum value maps for ControlResult.
var (
	ControlResult_name = map[int32]string{
		0: "CONTROL_UNSPECIFIED",
		1: "CONTROL_SUCCESS",
		2: "CONTROL_ALREADY_COMPLETED",
		3: "CONTROL_ALREADY_CANCELLED",
		4: "CONTROL_NOT_FOUND",
		5: "CONTROL_OPERATION_FAILED",
	}
	ControlResult_value = map[string]int32{
		"CONTROL_UNSPECIFIED":       0,
		"CONTROL_SUCCESS":           1,
		"CONTROL_ALREADY_COMPLETED": 2,
		"CONTROL_ALREADY_CANCELLED": 3,
		"CONTROL_NOT_FOUND":         4,
		"CONTROL_OPERATION_FAILED":  5,
	}
)

func (x ControlResult) Enum() *ControlResult {
	p := new(ControlResult)
	*p = x
	return p
}

func (x ControlResult) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ControlResult) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[2].Descriptor()
}

func (ControlResult) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[2]
}

func (x ControlResult) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ControlResult.Descriptor instead.
func (ControlResult) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{2}
}

// 查询类型
type QueryType int32

const (
	QueryType_QUERY_UNSPECIFIED QueryType = 0 // 未知类型
	QueryType_QUERY_STATUS      QueryType = 1 // 查询状态
	QueryType_QUERY_HISTORY     QueryType = 2 // 查询历史
	QueryType_QUERY_STACK_TRACE QueryType = 3 // 查询堆栈跟踪
)

// Enum value maps for QueryType.
var (
	QueryType_name = map[int32]string{
		0: "QUERY_UNSPECIFIED",
		1: "QUERY_STATUS",
		2: "QUERY_HISTORY",
		3: "QUERY_STACK_TRACE",
	}
	QueryType_value = map[string]int32{
		"QUERY_UNSPECIFIED": 0,
		"QUERY_STATUS":      1,
		"QUERY_HISTORY":     2,
		"QUERY_STACK_TRACE": 3,
	}
)

func (x QueryType) Enum() *QueryType {
	p := new(QueryType)
	*p = x
	return p
}

func (x QueryType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (QueryType) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[3].Descriptor()
}

func (QueryType) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[3]
}

func (x QueryType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use QueryType.Descriptor instead.
func (QueryType) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{3}
}

// 工作流状态枚举
type WorkflowState int32

const (
	WorkflowState_STATE_UNSPECIFIED      WorkflowState = 0 // 未知类型
	WorkflowState_STATE_RUNNING          WorkflowState = 1
	WorkflowState_STATE_COMPLETED        WorkflowState = 2
	WorkflowState_STATE_FAILED           WorkflowState = 3
	WorkflowState_STATE_CANCELLED        WorkflowState = 4
	WorkflowState_STATE_TERMINATED       WorkflowState = 5
	WorkflowState_STATE_CONTINUED_AS_NEW WorkflowState = 6
	WorkflowState_STATE_TIMED_OUT        WorkflowState = 7
)

// Enum value maps for WorkflowState.
var (
	WorkflowState_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "STATE_RUNNING",
		2: "STATE_COMPLETED",
		3: "STATE_FAILED",
		4: "STATE_CANCELLED",
		5: "STATE_TERMINATED",
		6: "STATE_CONTINUED_AS_NEW",
		7: "STATE_TIMED_OUT",
	}
	WorkflowState_value = map[string]int32{
		"STATE_UNSPECIFIED":      0,
		"STATE_RUNNING":          1,
		"STATE_COMPLETED":        2,
		"STATE_FAILED":           3,
		"STATE_CANCELLED":        4,
		"STATE_TERMINATED":       5,
		"STATE_CONTINUED_AS_NEW": 6,
		"STATE_TIMED_OUT":        7,
	}
)

func (x WorkflowState) Enum() *WorkflowState {
	p := new(WorkflowState)
	*p = x
	return p
}

func (x WorkflowState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WorkflowState) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[4].Descriptor()
}

func (WorkflowState) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[4]
}

func (x WorkflowState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WorkflowState.Descriptor instead.
func (WorkflowState) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{4}
}

// 调度操作
type ScheduleOperation int32

const (
	ScheduleOperation_SCHEDULE_UNSPECIFIED ScheduleOperation = 0 // 未知类型
	ScheduleOperation_SCHEDULE_CREATE      ScheduleOperation = 1
	ScheduleOperation_SCHEDULE_UPDATE      ScheduleOperation = 2
	ScheduleOperation_SCHEDULE_DELETE      ScheduleOperation = 3
	ScheduleOperation_SCHEDULE_PAUSE       ScheduleOperation = 4
	ScheduleOperation_SCHEDULE_RESUME      ScheduleOperation = 5
)

// Enum value maps for ScheduleOperation.
var (
	ScheduleOperation_name = map[int32]string{
		0: "SCHEDULE_UNSPECIFIED",
		1: "SCHEDULE_CREATE",
		2: "SCHEDULE_UPDATE",
		3: "SCHEDULE_DELETE",
		4: "SCHEDULE_PAUSE",
		5: "SCHEDULE_RESUME",
	}
	ScheduleOperation_value = map[string]int32{
		"SCHEDULE_UNSPECIFIED": 0,
		"SCHEDULE_CREATE":      1,
		"SCHEDULE_UPDATE":      2,
		"SCHEDULE_DELETE":      3,
		"SCHEDULE_PAUSE":       4,
		"SCHEDULE_RESUME":      5,
	}
)

func (x ScheduleOperation) Enum() *ScheduleOperation {
	p := new(ScheduleOperation)
	*p = x
	return p
}

func (x ScheduleOperation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScheduleOperation) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[5].Descriptor()
}

func (ScheduleOperation) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[5]
}

func (x ScheduleOperation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScheduleOperation.Descriptor instead.
func (ScheduleOperation) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{5}
}

// 重叠策略
type OverlapPolicy int32

const (
	OverlapPolicy_OVERLAP_UNSPECIFIED     OverlapPolicy = 0 // 未知类型
	OverlapPolicy_OVERLAP_SKIP            OverlapPolicy = 1 // 跳过
	OverlapPolicy_OVERLAP_BUFFER_ONE      OverlapPolicy = 2 // 缓存一个
	OverlapPolicy_OVERLAP_BUFFER_ALL      OverlapPolicy = 3 // 缓存全部
	OverlapPolicy_OVERLAP_CANCEL_OTHER    OverlapPolicy = 4 // 取消其他
	OverlapPolicy_OVERLAP_TERMINATE_OTHER OverlapPolicy = 5 // 终止其他
	OverlapPolicy_OVERLAP_ALLOW_ALL       OverlapPolicy = 6 // 允许全部
)

// Enum value maps for OverlapPolicy.
var (
	OverlapPolicy_name = map[int32]string{
		0: "OVERLAP_UNSPECIFIED",
		1: "OVERLAP_SKIP",
		2: "OVERLAP_BUFFER_ONE",
		3: "OVERLAP_BUFFER_ALL",
		4: "OVERLAP_CANCEL_OTHER",
		5: "OVERLAP_TERMINATE_OTHER",
		6: "OVERLAP_ALLOW_ALL",
	}
	OverlapPolicy_value = map[string]int32{
		"OVERLAP_UNSPECIFIED":     0,
		"OVERLAP_SKIP":            1,
		"OVERLAP_BUFFER_ONE":      2,
		"OVERLAP_BUFFER_ALL":      3,
		"OVERLAP_CANCEL_OTHER":    4,
		"OVERLAP_TERMINATE_OTHER": 5,
		"OVERLAP_ALLOW_ALL":       6,
	}
)

func (x OverlapPolicy) Enum() *OverlapPolicy {
	p := new(OverlapPolicy)
	*p = x
	return p
}

func (x OverlapPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OverlapPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[6].Descriptor()
}

func (OverlapPolicy) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[6]
}

func (x OverlapPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OverlapPolicy.Descriptor instead.
func (OverlapPolicy) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{6}
}

// 调度状态
type ScheduleState int32

const (
	ScheduleState__UNSPECIFIED     ScheduleState = 0 // 未知类型
	ScheduleState_SCHEDULE_ACTIVE  ScheduleState = 1
	ScheduleState_SCHEDULE_PAUSED  ScheduleState = 2
	ScheduleState_SCHEDULE_DELETED ScheduleState = 3
)

// Enum value maps for ScheduleState.
var (
	ScheduleState_name = map[int32]string{
		0: "_UNSPECIFIED",
		1: "SCHEDULE_ACTIVE",
		2: "SCHEDULE_PAUSED",
		3: "SCHEDULE_DELETED",
	}
	ScheduleState_value = map[string]int32{
		"_UNSPECIFIED":     0,
		"SCHEDULE_ACTIVE":  1,
		"SCHEDULE_PAUSED":  2,
		"SCHEDULE_DELETED": 3,
	}
)

func (x ScheduleState) Enum() *ScheduleState {
	p := new(ScheduleState)
	*p = x
	return p
}

func (x ScheduleState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScheduleState) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_v1_temporal_types_proto_enumTypes[7].Descriptor()
}

func (ScheduleState) Type() protoreflect.EnumType {
	return &file_temporal_v1_temporal_types_proto_enumTypes[7]
}

func (x ScheduleState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScheduleState.Descriptor instead.
func (ScheduleState) EnumDescriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{7}
}

// 统一的工作流选项
type WorkflowOptions struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	ExecutionTimeoutSeconds int32                  `protobuf:"varint,1,opt,name=execution_timeout_seconds,json=executionTimeoutSeconds,proto3" json:"execution_timeout_seconds,omitempty"`
	RunTimeoutSeconds       int32                  `protobuf:"varint,2,opt,name=run_timeout_seconds,json=runTimeoutSeconds,proto3" json:"run_timeout_seconds,omitempty"`
	TaskTimeoutSeconds      int32                  `protobuf:"varint,3,opt,name=task_timeout_seconds,json=taskTimeoutSeconds,proto3" json:"task_timeout_seconds,omitempty"`
	RetryPolicy             *RetryPolicy           `protobuf:"bytes,4,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *WorkflowOptions) Reset() {
	*x = WorkflowOptions{}
	mi := &file_temporal_v1_temporal_types_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowOptions) ProtoMessage() {}

func (x *WorkflowOptions) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_v1_temporal_types_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowOptions.ProtoReflect.Descriptor instead.
func (*WorkflowOptions) Descriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{0}
}

func (x *WorkflowOptions) GetExecutionTimeoutSeconds() int32 {
	if x != nil {
		return x.ExecutionTimeoutSeconds
	}
	return 0
}

func (x *WorkflowOptions) GetRunTimeoutSeconds() int32 {
	if x != nil {
		return x.RunTimeoutSeconds
	}
	return 0
}

func (x *WorkflowOptions) GetTaskTimeoutSeconds() int32 {
	if x != nil {
		return x.TaskTimeoutSeconds
	}
	return 0
}

func (x *WorkflowOptions) GetRetryPolicy() *RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

// 统一的重试策略
type RetryPolicy struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	InitialIntervalSeconds int32                  `protobuf:"varint,1,opt,name=initial_interval_seconds,json=initialIntervalSeconds,proto3" json:"initial_interval_seconds,omitempty"`
	BackoffCoefficient     float32                `protobuf:"fixed32,2,opt,name=backoff_coefficient,json=backoffCoefficient,proto3" json:"backoff_coefficient,omitempty"`
	MaximumIntervalSeconds int32                  `protobuf:"varint,3,opt,name=maximum_interval_seconds,json=maximumIntervalSeconds,proto3" json:"maximum_interval_seconds,omitempty"`
	MaximumAttempts        int32                  `protobuf:"varint,4,opt,name=maximum_attempts,json=maximumAttempts,proto3" json:"maximum_attempts,omitempty"`
	NonRetryableErrorTypes []string               `protobuf:"bytes,5,rep,name=non_retryable_error_types,json=nonRetryableErrorTypes,proto3" json:"non_retryable_error_types,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *RetryPolicy) Reset() {
	*x = RetryPolicy{}
	mi := &file_temporal_v1_temporal_types_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetryPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetryPolicy) ProtoMessage() {}

func (x *RetryPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_v1_temporal_types_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetryPolicy.ProtoReflect.Descriptor instead.
func (*RetryPolicy) Descriptor() ([]byte, []int) {
	return file_temporal_v1_temporal_types_proto_rawDescGZIP(), []int{1}
}

func (x *RetryPolicy) GetInitialIntervalSeconds() int32 {
	if x != nil {
		return x.InitialIntervalSeconds
	}
	return 0
}

func (x *RetryPolicy) GetBackoffCoefficient() float32 {
	if x != nil {
		return x.BackoffCoefficient
	}
	return 0
}

func (x *RetryPolicy) GetMaximumIntervalSeconds() int32 {
	if x != nil {
		return x.MaximumIntervalSeconds
	}
	return 0
}

func (x *RetryPolicy) GetMaximumAttempts() int32 {
	if x != nil {
		return x.MaximumAttempts
	}
	return 0
}

func (x *RetryPolicy) GetNonRetryableErrorTypes() []string {
	if x != nil {
		return x.NonRetryableErrorTypes
	}
	return nil
}

var File_temporal_v1_temporal_types_proto protoreflect.FileDescriptor

const file_temporal_v1_temporal_types_proto_rawDesc = "" +
	"\n" +
	" temporal/v1/temporal_types.proto\x12\vtemporal.v1\"\xec\x01\n" +
	"\x0fWorkflowOptions\x12:\n" +
	"\x19execution_timeout_seconds\x18\x01 \x01(\x05R\x17executionTimeoutSeconds\x12.\n" +
	"\x13run_timeout_seconds\x18\x02 \x01(\x05R\x11runTimeoutSeconds\x120\n" +
	"\x14task_timeout_seconds\x18\x03 \x01(\x05R\x12taskTimeoutSeconds\x12;\n" +
	"\fretry_policy\x18\x04 \x01(\v2\x18.temporal.v1.RetryPolicyR\vretryPolicy\"\x98\x02\n" +
	"\vRetryPolicy\x128\n" +
	"\x18initial_interval_seconds\x18\x01 \x01(\x05R\x16initialIntervalSeconds\x12/\n" +
	"\x13backoff_coefficient\x18\x02 \x01(\x02R\x12backoffCoefficient\x128\n" +
	"\x18maximum_interval_seconds\x18\x03 \x01(\x05R\x16maximumIntervalSeconds\x12)\n" +
	"\x10maximum_attempts\x18\x04 \x01(\x05R\x0fmaximumAttempts\x129\n" +
	"\x19non_retryable_error_types\x18\x05 \x03(\tR\x16nonRetryableErrorTypes*\x81\x01\n" +
	"\rExecutionMode\x12\x14\n" +
	"\x10MODE_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eMODE_IMMEDIATE\x10\x01\x12\x10\n" +
	"\fMODE_DELAYED\x10\x02\x12\x12\n" +
	"\x0eMODE_SCHEDULED\x10\x03\x12\x10\n" +
	"\fMODE_AT_TIME\x10\x04\x12\x0e\n" +
	"\n" +
	"MODE_BATCH\x10\x05*x\n" +
	"\x10ControlOperation\x12\x13\n" +
	"\x0fOPT_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"OPT_CANCEL\x10\x01\x12\x11\n" +
	"\rOPT_TERMINATE\x10\x02\x12\r\n" +
	"\tOPT_PAUSE\x10\x03\x12\x0e\n" +
	"\n" +
	"OPT_RESUME\x10\x04\x12\r\n" +
	"\tOPT_RESET\x10\x05*\xb0\x01\n" +
	"\rControlResult\x12\x17\n" +
	"\x13CONTROL_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fCONTROL_SUCCESS\x10\x01\x12\x1d\n" +
	"\x19CONTROL_ALREADY_COMPLETED\x10\x02\x12\x1d\n" +
	"\x19CONTROL_ALREADY_CANCELLED\x10\x03\x12\x15\n" +
	"\x11CONTROL_NOT_FOUND\x10\x04\x12\x1c\n" +
	"\x18CONTROL_OPERATION_FAILED\x10\x05*^\n" +
	"\tQueryType\x12\x15\n" +
	"\x11QUERY_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fQUERY_STATUS\x10\x01\x12\x11\n" +
	"\rQUERY_HISTORY\x10\x02\x12\x15\n" +
	"\x11QUERY_STACK_TRACE\x10\x03*\xbc\x01\n" +
	"\rWorkflowState\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rSTATE_RUNNING\x10\x01\x12\x13\n" +
	"\x0fSTATE_COMPLETED\x10\x02\x12\x10\n" +
	"\fSTATE_FAILED\x10\x03\x12\x13\n" +
	"\x0fSTATE_CANCELLED\x10\x04\x12\x14\n" +
	"\x10STATE_TERMINATED\x10\x05\x12\x1a\n" +
	"\x16STATE_CONTINUED_AS_NEW\x10\x06\x12\x13\n" +
	"\x0fSTATE_TIMED_OUT\x10\a*\x95\x01\n" +
	"\x11ScheduleOperation\x12\x18\n" +
	"\x14SCHEDULE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fSCHEDULE_CREATE\x10\x01\x12\x13\n" +
	"\x0fSCHEDULE_UPDATE\x10\x02\x12\x13\n" +
	"\x0fSCHEDULE_DELETE\x10\x03\x12\x12\n" +
	"\x0eSCHEDULE_PAUSE\x10\x04\x12\x13\n" +
	"\x0fSCHEDULE_RESUME\x10\x05*\xb8\x01\n" +
	"\rOverlapPolicy\x12\x17\n" +
	"\x13OVERLAP_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fOVERLAP_SKIP\x10\x01\x12\x16\n" +
	"\x12OVERLAP_BUFFER_ONE\x10\x02\x12\x16\n" +
	"\x12OVERLAP_BUFFER_ALL\x10\x03\x12\x18\n" +
	"\x14OVERLAP_CANCEL_OTHER\x10\x04\x12\x1b\n" +
	"\x17OVERLAP_TERMINATE_OTHER\x10\x05\x12\x15\n" +
	"\x11OVERLAP_ALLOW_ALL\x10\x06*a\n" +
	"\rScheduleState\x12\x10\n" +
	"\f_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fSCHEDULE_ACTIVE\x10\x01\x12\x13\n" +
	"\x0fSCHEDULE_PAUSED\x10\x02\x12\x14\n" +
	"\x10SCHEDULE_DELETED\x10\x03B8Z6github.com/og-game/game-proto/proto-gen-go/temporal/v1b\x06proto3"

var (
	file_temporal_v1_temporal_types_proto_rawDescOnce sync.Once
	file_temporal_v1_temporal_types_proto_rawDescData []byte
)

func file_temporal_v1_temporal_types_proto_rawDescGZIP() []byte {
	file_temporal_v1_temporal_types_proto_rawDescOnce.Do(func() {
		file_temporal_v1_temporal_types_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_v1_temporal_types_proto_rawDesc), len(file_temporal_v1_temporal_types_proto_rawDesc)))
	})
	return file_temporal_v1_temporal_types_proto_rawDescData
}

var file_temporal_v1_temporal_types_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_temporal_v1_temporal_types_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_temporal_v1_temporal_types_proto_goTypes = []any{
	(ExecutionMode)(0),      // 0: temporal.v1.ExecutionMode
	(ControlOperation)(0),   // 1: temporal.v1.ControlOperation
	(ControlResult)(0),      // 2: temporal.v1.ControlResult
	(QueryType)(0),          // 3: temporal.v1.QueryType
	(WorkflowState)(0),      // 4: temporal.v1.WorkflowState
	(ScheduleOperation)(0),  // 5: temporal.v1.ScheduleOperation
	(OverlapPolicy)(0),      // 6: temporal.v1.OverlapPolicy
	(ScheduleState)(0),      // 7: temporal.v1.ScheduleState
	(*WorkflowOptions)(nil), // 8: temporal.v1.WorkflowOptions
	(*RetryPolicy)(nil),     // 9: temporal.v1.RetryPolicy
}
var file_temporal_v1_temporal_types_proto_depIdxs = []int32{
	9, // 0: temporal.v1.WorkflowOptions.retry_policy:type_name -> temporal.v1.RetryPolicy
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_temporal_v1_temporal_types_proto_init() }
func file_temporal_v1_temporal_types_proto_init() {
	if File_temporal_v1_temporal_types_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_v1_temporal_types_proto_rawDesc), len(file_temporal_v1_temporal_types_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_v1_temporal_types_proto_goTypes,
		DependencyIndexes: file_temporal_v1_temporal_types_proto_depIdxs,
		EnumInfos:         file_temporal_v1_temporal_types_proto_enumTypes,
		MessageInfos:      file_temporal_v1_temporal_types_proto_msgTypes,
	}.Build()
	File_temporal_v1_temporal_types_proto = out.File
	file_temporal_v1_temporal_types_proto_goTypes = nil
	file_temporal_v1_temporal_types_proto_depIdxs = nil
}
